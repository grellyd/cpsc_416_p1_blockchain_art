TODO:

----------
Phase 1: Infrastructure
-----------
Sharon := shape addition validation, add helper to determine how much ink an operation takes. Add ink used field to operation.
Alex := RPC (done), miner -> server (done), applib <-> miner (done), NewMiner (done), NewArtNode (done)
Graham := Restructure and ink generation, serialise and deserialise block; Add field BCLength to retrieve length of BC.
Larissa := miner to miner communication

Graham Deliverable (Post Alex Done) -> Able to start multiple miners from ink
nodes, and provide no operations. The miners will all start NOPing and
generating ink for the InkNodes to use.

----------
Phase 2: Blockchain & Blockchain RPC Calls
-----------
Alex := implement GetInk(), GetGenesisBlock(), and GetChildren(); think about stubs for BC.

Graham := Block propagation
Graham := Block Validation
Graham := Switching to a new longest chain (stop/start mining)
Graham := Miner main loop
Larissa := Miner intial join chain revceive
Alex := Tree comparisons for the purposes of choosing the longest chain.
Alex := Given a valid block, check if new longest chain.
    func IsNewLongestChain(b *Block) bool
Alex := Fix requesting neighbors from the server
:= Share operations to other miners
:= Has operation already been completed
:= Shape Addition Validation -> Validate an operation can go on the Canvas
:= Choose #OPs per block, and timeout to start mining


----------
Phase 3: Azure Deployment
----------





----------
Phase 4: Bonuses
-----------

----------
Notes
-----------

----------
How to run several miners (and apps)
-----------
1. Run key-gen.go (each run 1 set of [Private][Public] keys).
2. Each time copy the values you get somewhere.
3. Run server
4. Run every miner with the arguments 127.0.0.1:12345 [publ][priv]
5. If you want to run an app, you'll need to copy miner's IP:Port from terminal printout (it's randomly picked) and copy private key for that miner.
6. Manually insert into art-app.go private key and IP:Port combination
7. Run App.
